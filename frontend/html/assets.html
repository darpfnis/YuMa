<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Assets - YuMa</title>
    <link rel="stylesheet" href="../css/styles.css">
    <link rel="stylesheet" href="../css/header.css">
    <link rel="stylesheet" href="../css/global.css">
    /*<link rel="stylesheet" href="../css/assets_custom.css"> <!-- This will now apply the new light theme -->*/
</head>
<body>
    <header>
        <div class="header-left">
            <div class="logo"><a href="../../index.html">YuMa</a></div>
            <nav class="main-nav">
                <a href="buy_crypto-page.html">Buy Crypto</a>
                <a href="markets.html">Markets</a>
                <div class="dropdown-container">
                    <a href="#" class="nav-link dropdown-toggle">Trade</a>
                    <div class="dropdown-content trade-dropdown">
                        <div class="dropdown-column">
                            <a href="spot-page.html">Spot</a>
                            <a href="#">Margin</a>
                            <a href="#">P2P</a>
                            <a href="#">Convert & Block Trade</a>
                        </div>
                    </div>
                </div>
                <div class="dropdown-container">
                    <a href="#" class="nav-link dropdown-toggle">Futures</a>
                    <div class="dropdown-content futures-dropdown">
                        <a href="futures-page.html">USDⓈ-M Futures</a>
                        <a href="#">COIN-M Futures</a>
                        <a href="#">Options</a>
                        <a href="#">Leaderboard</a>
                    </div>
                </div>
                <a href="#">FAQ</a>
            </nav>
        </div>
        <nav class="user-nav">
            <a href="sign_up-page.html" id="signUpLinkAssets">Sign up</a>
            <a href="login-page.html" id="loginLinkAssets">Log in</a>
            <span id="userGreetingAssets" style="display: none; margin-right: 15px; color: #e0e0e0;"></span>
            <button id="logoutButtonAssets" class="nav-button" style="display: none;">Log out</button>
        </nav>
    </header>

    <div class="page-wrapper-profile">
        <aside class="sidebar">
            <nav>
                <a href="profile.html" class="sidebar-button">Dashboard</a>
                <a href="assets.html" class="sidebar-button active">Assets</a>
                <a href="order.html" class="sidebar-button">Orders</a>
                <a href="account.html" class="sidebar-button">Account</a>
                <a href="settings.html" class="sidebar-button">Settings</a>
            </nav>
        </aside>

        <main class="main-content-profile">
            <section class="content-header">
                <h2>My Assets</h2>
                <!-- <button class="action-button primary-action">View Transaction History</button> -->
            </section>

            <section class="profile-card asset-overview">
                <div class="overview-item">
                    <span class="label">Total Portfolio Value (USD):</span>
                    <span class="value total-value-dynamic" id="totalPortfolioValue">$0.00</span>
                </div>
            </section>

            <section class="assets-list-section">
                <div class="table-controls">
                    <input type="text" id="searchAssetInput" placeholder="Search coin..." class="search-input">
                    <label class="checkbox-label">
                        <input type="checkbox" id="hideZeroBalancesCheckbox"> Hide zero balances
                    </label>
                </div>

                <div class="custom-table-wrapper" id="assetsTableContainer">
                    <div class="custom-table-header">
                        <span>Coin</span>
                        <span>Total Balance</span>
                        <span>Available</span>
                        <span>In Orders</span>
                        <span>Value (USD)</span>
                        <span>Actions</span>
                    </div>
                    <div class="no-data-placeholder">Loading assets...</div>
                </div>
                <div class="show-all-container" style="text-align: center; margin-top: 20px; display: none;">
                    <button id="showAllAssetsButton" class="action-button">Show All Assets</button>
                </div>
            </section>
        </main>
    </div>

<script>
document.addEventListener('DOMContentLoaded', async () => {
    console.log('[AssetsPage] DOMContentLoaded. Script loaded.');
    const token = localStorage.getItem('authToken');

    const logoutButton = document.getElementById('logoutButtonAssets');
    const signUpLink = document.getElementById('signUpLinkAssets');
    const loginLink = document.getElementById('loginLinkAssets');
    const userGreeting = document.getElementById('userGreetingAssets');

    const totalPortfolioValueElement = document.getElementById('totalPortfolioValue');
    const assetsTableContainer = document.getElementById('assetsTableContainer');
    const searchAssetInput = document.getElementById('searchAssetInput');
    const hideZeroBalancesCheckbox = document.getElementById('hideZeroBalancesCheckbox');
    const showAllAssetsButton = document.getElementById('showAllAssetsButton');
    const showAllContainer = document.querySelector('.show-all-container');

    let allFetchedAssets = [];
    const initialDisplayLimit = 10; // Show 10 assets initially
    let currentlyDisplayingAll = false;
    let binanceWebSocket = null;
    let subscribedSymbols = new Set();
    let wsReconnectInterval = null; // For managing reconnection attempts

    // --- WebSocket Connection and Management ---
    function connectBinanceWebSocket() {
        if (binanceWebSocket && (binanceWebSocket.readyState === WebSocket.OPEN || binanceWebSocket.readyState === WebSocket.CONNECTING)) {
            // console.log('[AssetsPage] Binance WebSocket is already open or connecting.');
            return;
        }
        
        if (wsReconnectInterval) {
            clearInterval(wsReconnectInterval);
            wsReconnectInterval = null;
        }

        console.log('[AssetsPage] Attempting to connect to Binance WebSocket...');
        const wsUrl = 'wss://stream.binance.com:9443/ws';
        binanceWebSocket = new WebSocket(wsUrl);

        binanceWebSocket.onopen = () => {
            console.log('[AssetsPage] Binance WebSocket connection established.');
            if (wsReconnectInterval) { 
                clearInterval(wsReconnectInterval);
                wsReconnectInterval = null;
            }
            if (allFetchedAssets.length > 0) {
                subscribeToAssetTickers(allFetchedAssets);
            }
        };

        binanceWebSocket.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                if (message.e === '24hrTicker') {
                    const symbol = message.s; 
                    const price = parseFloat(message.c);

                    let assetUpdated = false;
                    allFetchedAssets = allFetchedAssets.map(asset => {
                        const pairSymbol = `${asset.coin_symbol.toUpperCase()}USDT`;
                        if (pairSymbol === symbol && asset.coin_symbol.toUpperCase() !== 'USDT') {
                            const newUsdValue = (parseFloat(asset.total_balance) * price);
                            if (Math.abs(parseFloat(asset.value_usd) - newUsdValue) > 0.001) {
                                asset.value_usd = newUsdValue.toFixed(2); 
                                assetUpdated = true;
                            }
                        }
                        return asset;
                    });

                    if (assetUpdated) {
                        updateSpecificAssetRowAndTotal(symbol.replace('USDT',''), price); 
                        recalculateAndRenderTotalPortfolioValue(); 
                    }
                } else if (message.result === null && message.id) {
                    // console.log(`[AssetsPage] WebSocket ack ID ${message.id}`);
                }
            } catch (error) {
                console.error('[AssetsPage] Error processing WebSocket message:', error, event.data);
            }
        };

        binanceWebSocket.onerror = (error) => {
            console.error('[AssetsPage] Binance WebSocket error:', error);
        };

        binanceWebSocket.onclose = (event) => {
            console.log(`[AssetsPage] Binance WebSocket connection closed. Code: ${event.code}, Reason: '${event.reason}'`);
            binanceWebSocket = null;
            subscribedSymbols.clear();
            if (!wsReconnectInterval && token) { 
                console.log('[AssetsPage] Attempting to reconnect WebSocket in 5 seconds...');
                wsReconnectInterval = setInterval(() => {
                    if (!binanceWebSocket || binanceWebSocket.readyState === WebSocket.CLOSED) {
                         console.log('[AssetsPage] Retrying WebSocket connection...');
                         connectBinanceWebSocket();
                    } else if (binanceWebSocket && binanceWebSocket.readyState === WebSocket.OPEN) {
                        clearInterval(wsReconnectInterval); 
                        wsReconnectInterval = null;
                    }
                }, 5000); 
            }
        };
    }
    
    function updateSpecificAssetRowAndTotal(baseAssetSymbol, newPrice) {
        const assetRow = assetsTableContainer.querySelector(`.custom-table-row[data-asset-symbol="${baseAssetSymbol.toUpperCase()}"]`);
        if (assetRow) {
            const asset = allFetchedAssets.find(a => a.coin_symbol.toUpperCase() === baseAssetSymbol.toUpperCase());
            if (asset) {
                const valueCell = assetRow.querySelector('.asset-value-usd');
                if (valueCell) {
                    valueCell.textContent = `$${parseFloat(asset.value_usd).toFixed(2)}`;
                }
            }
        }
    }

    function subscribeToAssetTickers(assets) {
        if (!binanceWebSocket || binanceWebSocket.readyState !== WebSocket.OPEN) {
            if (!wsReconnectInterval && token) connectBinanceWebSocket(); 
            return;
        }

        const newSymbolsToSubscribe = [];
        assets.forEach(asset => {
            const symbol = asset.coin_symbol.toUpperCase();
            if (symbol !== 'USDT' && symbol !== 'USD' && symbol !== 'USDC' && symbol !== 'BUSD') { 
                const pair = `${symbol}USDT`;
                if (!subscribedSymbols.has(pair)) {
                    newSymbolsToSubscribe.push(`${pair.toLowerCase()}@ticker`);
                }
            }
        });

        if (newSymbolsToSubscribe.length > 0) {
            const currentAssetPairs = new Set(assets.map(a => `${a.coin_symbol.toUpperCase()}USDT`));
            const symbolsToUnsubscribeImmediately = [];
            subscribedSymbols.forEach(subscribedPair => {
                if (!currentAssetPairs.has(subscribedPair) && 
                    !subscribedPair.endsWith('USDT') && 
                    !subscribedPair.endsWith('USD') &&
                    !subscribedPair.endsWith('USDC') &&
                    !subscribedPair.endsWith('BUSD')) {
                    symbolsToUnsubscribeImmediately.push(`${subscribedPair.toLowerCase()}@ticker`);
                }
            });

            if (symbolsToUnsubscribeImmediately.length > 0) {
                 binanceWebSocket.send(JSON.stringify({
                    method: "UNSUBSCRIBE",
                    params: symbolsToUnsubscribeImmediately,
                    id: Date.now()
                }));
                symbolsToUnsubscribeImmediately.forEach(s => subscribedSymbols.delete(s.replace('@ticker','').toUpperCase()));
                console.log('[AssetsPage] Unsubscribed from obsolete tickers:', symbolsToUnsubscribeImmediately);
            }

            binanceWebSocket.send(JSON.stringify({
                method: "SUBSCRIBE",
                params: newSymbolsToSubscribe,
                id: Date.now() + 1
            }));
            newSymbolsToSubscribe.forEach(s => subscribedSymbols.add(s.replace('@ticker','').toUpperCase()));
            console.log('[AssetsPage] Subscribing to tickers:', newSymbolsToSubscribe);
        }
    }
    
    function unsubscribeFromAllTickers(clearLocally = true) {
        if (binanceWebSocket && binanceWebSocket.readyState === WebSocket.OPEN && subscribedSymbols.size > 0) {
            const symbolsToUnsubscribe = Array.from(subscribedSymbols).map(s => `${s.toLowerCase()}@ticker`);
            binanceWebSocket.send(JSON.stringify({
                method: "UNSUBSCRIBE",
                params: symbolsToUnsubscribe,
                id: Date.now()
            }));
            console.log('[AssetsPage] Sent unsubscribe request for tickers:', symbolsToUnsubscribe);
        }
        if (clearLocally) {
            subscribedSymbols.clear();
        }
    }

    if (token) {
        if(logoutButton) logoutButton.style.display = 'inline-block';
        if(signUpLink) signUpLink.style.display = 'none';
        if(loginLink) loginLink.style.display = 'none';
        if(logoutButton) {
            logoutButton.addEventListener('click', async () => {
                console.log('[AssetsPage] Logout clicked.');
                if (wsReconnectInterval) { clearInterval(wsReconnectInterval); wsReconnectInterval = null;}
                unsubscribeFromAllTickers();
                if (binanceWebSocket && binanceWebSocket.readyState === WebSocket.OPEN) {
                     binanceWebSocket.close(1000, "User logged out"); 
                }
                binanceWebSocket = null; 

                const currentToken = localStorage.getItem('authToken');
                localStorage.removeItem('authToken');
                try {
                    await fetch('/auth/logout', { method: 'POST', headers: { 'Authorization': `Bearer ${currentToken}` }});
                } catch(e) { console.error('Logout API error', e); }
                window.location.href = 'login-page.html';
            });
        }
    } else {
        console.warn('[AssetsPage] No token. Redirecting to login.');
        if(logoutButton) logoutButton.style.display = 'none';
        if(signUpLink) signUpLink.style.display = 'inline-block';
        if(loginLink) loginLink.style.display = 'inline-block';
        if(userGreeting) userGreeting.style.display = 'none';
        window.location.href = 'login-page.html';
        return;
    }

    async function fetchProtectedData(url, options = {}) {
        const currentToken = localStorage.getItem('authToken');
        if (!currentToken) {
            window.location.href = 'login-page.html';
            return Promise.reject(new Error('No token, redirecting.'));
        }
        const defaultHeaders = {
            'Authorization': `Bearer ${currentToken}`,
            'Content-Type': 'application/json'
        };
        const fetchOptions = { ...options, headers: { ...defaultHeaders, ...options.headers } };
        try {
            const response = await fetch(url, fetchOptions);
            if (!response.ok) {
                if (response.status === 401 || response.status === 403) {
                    if (wsReconnectInterval) { clearInterval(wsReconnectInterval); wsReconnectInterval = null; }
                    unsubscribeFromAllTickers();
                    if (binanceWebSocket) binanceWebSocket.close(1000, "Unauthorized");
                    binanceWebSocket = null;
                    localStorage.removeItem('authToken');
                    window.location.href = 'login-page.html';
                    return Promise.reject(new Error('Unauthorized or Forbidden, redirecting.'));
                }
                const errorData = await response.json().catch(() => ({ message: `HTTP error! Status: ${response.status}` }));
                console.error(`[fetchProtectedData] Error for ${url}:`, errorData.message || response.status);
                return Promise.reject(errorData);
            }
            return response.json();
        } catch (error) {
            console.error(`[fetchProtectedData] Network or other error for ${url}:`, error);
            return Promise.reject(error);
        }
    }

    function renderAssets(assetsToRender) {
        const header = assetsTableContainer.querySelector('.custom-table-header');
        const existingRows = assetsTableContainer.querySelectorAll('.custom-table-row');
        existingRows.forEach(row => row.remove()); 

        const noDataPlaceholder = assetsTableContainer.querySelector('.no-data-placeholder');
        if (noDataPlaceholder) noDataPlaceholder.remove();

        if (!assetsToRender || assetsToRender.length === 0) {
            const message = (searchAssetInput.value || hideZeroBalancesCheckbox.checked) ? 'No assets found matching your criteria.' : 'You have no assets yet.';
            assetsTableContainer.insertAdjacentHTML('beforeend', `<div class="no-data-placeholder">${message}</div>`);
             if (totalPortfolioValueElement) totalPortfolioValueElement.textContent = '$0.00'; 
            return;
        }

        const fragment = document.createDocumentFragment();
        assetsToRender.forEach(asset => {
            const row = document.createElement('div');
            row.classList.add('custom-table-row', 'asset-row');
            row.dataset.assetSymbol = asset.coin_symbol.toUpperCase();

            const valueUSD = parseFloat(asset.value_usd) || 0;
            const displayName = asset.coin_name && asset.coin_name !== asset.coin_symbol ? asset.coin_name : asset.coin_symbol;
            const quantityPrecision = asset.quantity_precision !== undefined ? parseInt(asset.quantity_precision) : 8;

            // **РЕКОМЕНДОВАНА ЗМІНА тут: .coin-symbol-display -> .coin-symbol**
            row.innerHTML = `
                <span class="coin-details">
                    <span class="coin-name-full">${displayName}</span><span class="coin-symbol">(${asset.coin_symbol.toUpperCase()})</span>
                </span>
                <span>${parseFloat(asset.total_balance).toFixed(quantityPrecision)}</span>
                <span>${parseFloat(asset.available_balance).toFixed(quantityPrecision)}</span>
                <span>${parseFloat(asset.in_order_balance).toFixed(quantityPrecision)}</span>
                <span class="asset-value-usd">$${valueUSD.toFixed(2)}</span>
                <span class="asset-actions">
                    <a href="deposit-page.html?coin=${asset.coin_symbol.toLowerCase()}" class="action-link">Deposit</a>
                    <a href="withdraw-page.html?coin=${asset.coin_symbol.toLowerCase()}" class="action-link">Withdraw</a>
                    <a href="spot-page.html?pair=${asset.coin_symbol.toUpperCase()}USDT" class="action-link">Trade</a>
                </span>
            `;
            fragment.appendChild(row);
        });
        assetsTableContainer.appendChild(fragment);

        recalculateAndRenderTotalPortfolioValue();

        if (allFetchedAssets.length > initialDisplayLimit && !currentlyDisplayingAll) {
            if (showAllContainer) showAllContainer.style.display = 'block';
        } else {
            if (showAllContainer) showAllContainer.style.display = 'none';
        }
    }
    
    function recalculateAndRenderTotalPortfolioValue() {
        let calculatedTotalPortfolioValue = 0;
        allFetchedAssets.forEach(asset => {
            calculatedTotalPortfolioValue += parseFloat(asset.value_usd) || 0;
        });
        if (totalPortfolioValueElement) {
            totalPortfolioValueElement.textContent = `$${calculatedTotalPortfolioValue.toFixed(2)}`;
        }
    }

    function filterAndPrepareAssets() {
        const searchTerm = searchAssetInput.value.toLowerCase();
        const hideZero = hideZeroBalancesCheckbox.checked;

        let filteredAssets = allFetchedAssets.filter(asset => {
            const nameMatch = asset.coin_name ? asset.coin_name.toLowerCase().includes(searchTerm) : false;
            const symbolMatch = asset.coin_symbol.toLowerCase().includes(searchTerm);
            const matchesSearch = nameMatch || symbolMatch;
            
            const nonZeroBalance = parseFloat(asset.total_balance) > 1e-9; 
            return matchesSearch && (!hideZero || nonZeroBalance);
        });

        filteredAssets.sort((a, b) => {
            const aBalance = parseFloat(a.total_balance);
            const bBalance = parseFloat(b.total_balance);
            const aValue = parseFloat(a.value_usd) || 0;
            const bValue = parseFloat(b.value_usd) || 0;

            if (aBalance > 1e-9 && bBalance <= 1e-9) return -1;
            if (bBalance > 1e-9 && aBalance <= 1e-9) return 1;  
            
            return bValue - aValue;
        });
        
        const assetsToDisplay = currentlyDisplayingAll ? filteredAssets : filteredAssets.slice(0, initialDisplayLimit);
        renderAssets(assetsToDisplay);
    }

    async function loadAssets() {
        console.log('[AssetsPage] Attempting to load assets data...');
        const placeholder = assetsTableContainer.querySelector('.no-data-placeholder');
        if (placeholder) placeholder.textContent = 'Loading assets...';
        else { 
             const header = assetsTableContainer.querySelector('.custom-table-header');
             if (header && header.nextSibling === null) {
                const newPlaceholder = document.createElement('div');
                newPlaceholder.className = 'no-data-placeholder';
                newPlaceholder.textContent = 'Loading assets...';
                assetsTableContainer.appendChild(newPlaceholder);
             }
        }

        try {
            const data = await fetchProtectedData('/api/assets');
            if (data.success && data.assets) {
                allFetchedAssets = data.assets.map(asset => ({
                    ...asset,
                    quantity_precision: asset.quantity_precision !== undefined ? parseInt(asset.quantity_precision) : 8,
                    value_usd: parseFloat(asset.value_usd).toFixed(2) 
                }));
                currentlyDisplayingAll = false;
                if (showAllAssetsButton) showAllAssetsButton.textContent = 'Show All Assets';
                filterAndPrepareAssets();
                subscribeToAssetTickers(allFetchedAssets);
                console.log('[AssetsPage] Assets data processed and rendered.');
            } else {
                console.error('[AssetsPage] Failed to load assets from server:', data.message);
                const currentPlaceholder = assetsTableContainer.querySelector('.no-data-placeholder');
                if (currentPlaceholder) currentPlaceholder.textContent = data.message || 'Failed to load assets.';
            }
        } catch (error) {
            console.error('[AssetsPage] Error in loadAssets catcher:', error.message || error);
             const currentPlaceholder = assetsTableContainer.querySelector('.no-data-placeholder');
            if (currentPlaceholder) currentPlaceholder.textContent = 'Error loading assets. Please try again.';
        }
    }

    if(searchAssetInput) searchAssetInput.addEventListener('input', filterAndPrepareAssets);
    if(hideZeroBalancesCheckbox) hideZeroBalancesCheckbox.addEventListener('change', filterAndPrepareAssets);
    if(showAllAssetsButton) {
        showAllAssetsButton.addEventListener('click', () => {
            currentlyDisplayingAll = !currentlyDisplayingAll;
            showAllAssetsButton.textContent = currentlyDisplayingAll ? 'Show Less' : 'Show All Assets';
            filterAndPrepareAssets();
        });
    }
    
    window.addEventListener('beforeunload', () => {
        if (wsReconnectInterval) { clearInterval(wsReconnectInterval); }
        unsubscribeFromAllTickers(false); 
        if (binanceWebSocket && binanceWebSocket.readyState === WebSocket.OPEN) {
            binanceWebSocket.close(1000, "Page unloading");
        }
    });

    document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
            // console.log("[AssetsPage] Page is hidden. Consider pausing WebSocket updates if necessary.");
        } else {
            // console.log("[AssetsPage] Page is visible. Resubscribe if needed.");
            if (binanceWebSocket && binanceWebSocket.readyState === WebSocket.OPEN && subscribedSymbols.size === 0 && allFetchedAssets.length > 0) {
                // subscribeToAssetTickers(allFetchedAssets); // Можна розкоментувати для автоматичного перепідключення при видимості
            } else if ((!binanceWebSocket || binanceWebSocket.readyState === WebSocket.CLOSED) && token) {
                connectBinanceWebSocket();
            }
        }
    });

    loadAssets();
    if (token) { 
        connectBinanceWebSocket();
    }
});
</script>
</body>
</html>
